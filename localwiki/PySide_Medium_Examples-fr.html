<html><head><title>PySide Medium Examples/fr</title><meta http-equiv="Content-Type" content="text/html; charset=utf-8"><link type='text/css' href='wiki.css' rel='stylesheet'></head><body><h1>PySide Medium Examples/fr</h1></div>

<div id="mw-content-text" lang="fr" dir="ltr" class="mw-content-ltr"><hr/><div class="mw-parser-output"><div id="toc" class="toc"><div class="toctitle"><h2>Contents</h2></div>
<ul>
<li class="toclevel-1 tocsection-1"><a href="#Introduction"><span class="tocnumber">1</span> <span class="toctext">Introduction</span></a>
<ul>
<li class="toclevel-2 tocsection-2"><a href="#Notes"><span class="tocnumber">1.1</span> <span class="toctext">Notes</span></a></li>
</ul>
</li>
<li class="toclevel-1 tocsection-3"><a href="#Code_Based_Discussion_-_Declarative_Portion"><span class="tocnumber">2</span> <span class="toctext">Code Based Discussion - Declarative Portion</span></a>
<ul>
<li class="toclevel-2 tocsection-4"><a href="#Import_Statement"><span class="tocnumber">2.1</span> <span class="toctext">Import Statement</span></a></li>
<li class="toclevel-2 tocsection-5"><a href="#Class_Definition"><span class="tocnumber">2.2</span> <span class="toctext">Class Definition</span></a></li>
<li class="toclevel-2 tocsection-6"><a href="#Window_Return_Status"><span class="tocnumber">2.3</span> <span class="toctext">Window Return Status</span></a></li>
<li class="toclevel-2 tocsection-7"><a href="#Window_Creation"><span class="tocnumber">2.4</span> <span class="toctext">Window Creation</span></a></li>
<li class="toclevel-2 tocsection-8"><a href="#Label_Creation"><span class="tocnumber">2.5</span> <span class="toctext">Label Creation</span></a></li>
<li class="toclevel-2 tocsection-9"><a href="#Checkbox_Creation"><span class="tocnumber">2.6</span> <span class="toctext">Checkbox Creation</span></a></li>
<li class="toclevel-2 tocsection-10"><a href="#Radio_Button_Creation"><span class="tocnumber">2.7</span> <span class="toctext">Radio Button Creation</span></a></li>
<li class="toclevel-2 tocsection-11"><a href="#Pop-Up_Menu_Creation"><span class="tocnumber">2.8</span> <span class="toctext">Pop-Up Menu Creation</span></a></li>
<li class="toclevel-2 tocsection-12"><a href="#Button_Creation_Part_1"><span class="tocnumber">2.9</span> <span class="toctext">Button Creation Part 1</span></a></li>
<li class="toclevel-2 tocsection-13"><a href="#Text_Input_Creation"><span class="tocnumber">2.10</span> <span class="toctext">Text Input Creation</span></a></li>
<li class="toclevel-2 tocsection-14"><a href="#Contextual_Menu_Creation"><span class="tocnumber">2.11</span> <span class="toctext">Contextual Menu Creation</span></a></li>
<li class="toclevel-2 tocsection-15"><a href="#Numeric_Input_Creation"><span class="tocnumber">2.12</span> <span class="toctext">Numeric Input Creation</span></a></li>
<li class="toclevel-2 tocsection-16"><a href="#Button_Creation_Part_2"><span class="tocnumber">2.13</span> <span class="toctext">Button Creation Part 2</span></a></li>
<li class="toclevel-2 tocsection-17"><a href="#Window_Display"><span class="tocnumber">2.14</span> <span class="toctext">Window Display</span></a></li>
</ul>
</li>
<li class="toclevel-1 tocsection-18"><a href="#Code_Based_Discussion_-_Operative_Portion"><span class="tocnumber">3</span> <span class="toctext">Code Based Discussion - Operative Portion</span></a>
<ul>
<li class="toclevel-2 tocsection-19"><a href="#Generic_Handler"><span class="tocnumber">3.1</span> <span class="toctext">Generic Handler</span></a></li>
<li class="toclevel-2 tocsection-20"><a href="#Pop-Up_Menu_Handler"><span class="tocnumber">3.2</span> <span class="toctext">Pop-Up Menu Handler</span></a></li>
<li class="toclevel-2 tocsection-21"><a href="#Mouse_Event_Handler"><span class="tocnumber">3.3</span> <span class="toctext">Mouse Event Handler</span></a></li>
</ul>
</li>
<li class="toclevel-1 tocsection-22"><a href="#Code_Based_Discussion_-_Main_Routine"><span class="tocnumber">4</span> <span class="toctext">Code Based Discussion - Main Routine</span></a></li>
<li class="toclevel-1 tocsection-23"><a href="#Complete_Modal_Code_Example"><span class="tocnumber">5</span> <span class="toctext">Complete Modal Code Example</span></a></li>
<li class="toclevel-1 tocsection-24"><a href="#Code_Based_Discussion_-_Nonmodal_Code_Example"><span class="tocnumber">6</span> <span class="toctext">Code Based Discussion - Nonmodal Code Example</span></a>
<ul>
<li class="toclevel-2 tocsection-25"><a href="#Import_Statement_2"><span class="tocnumber">6.1</span> <span class="toctext">Import Statement</span></a></li>
<li class="toclevel-2 tocsection-26"><a href="#Class_Definition_2"><span class="tocnumber">6.2</span> <span class="toctext">Class Definition</span></a></li>
<li class="toclevel-2 tocsection-27"><a href="#Window_Creation_2"><span class="tocnumber">6.3</span> <span class="toctext">Window Creation</span></a></li>
<li class="toclevel-2 tocsection-28"><a href="#Mouse_Move_Event_Handler"><span class="tocnumber">6.4</span> <span class="toctext">Mouse Move Event Handler</span></a></li>
<li class="toclevel-2 tocsection-29"><a href="#Invoking_the_Window"><span class="tocnumber">6.5</span> <span class="toctext">Invoking the Window</span></a></li>
</ul>
</li>
<li class="toclevel-1 tocsection-30"><a href="#Complete_Nonmodal_Code_Example"><span class="tocnumber">7</span> <span class="toctext">Complete Nonmodal Code Example</span></a></li>
<li class="toclevel-1 tocsection-31"><a href="#Misc_Additional_Topics"><span class="tocnumber">8</span> <span class="toctext">Misc Additional Topics</span></a>
<ul>
<li class="toclevel-2 tocsection-32"><a href="#Available_Screen_Size"><span class="tocnumber">8.1</span> <span class="toctext">Available Screen Size</span></a></li>
<li class="toclevel-2 tocsection-33"><a href="#Frame_Size_and_Geometry"><span class="tocnumber">8.2</span> <span class="toctext">Frame Size and Geometry</span></a></li>
</ul>
</li>
</ul>
</div>

<h2><span class="mw-headline" id="Introduction">Introduction</span></h2>
<p>This page covers medium level examples of the <a href="PySide.html" title="PySide">PySide</a> GUI manager (accompanying pages cover aspects that are both less or more advanced, <a href="PySide_Beginner_Examples.html" title="PySide Beginner Examples">Beginner PySide Examples</a> and 
<a href="PySide_Advanced_Examples.html" title="PySide Advanced Examples">Advanced PySide Examples</a>). In this page an example program is used to cover the different PySide topics. The intention is to present some functional PySide code so anyone who needs to use PySide can copy out the relevant section, modify and adapt it to their own purposes.
</p>
<h3><span class="mw-headline" id="Notes">Notes</span></h3>
<ul><li> This page is not intended to cover the Python language or to serve as an instruction in Python.</li>
<li> The variable names are not descriptive but have been kept in sequence to better organise the explanations</li>
<li> There are numerous naming conventions for GUI components, none of which are "right" or "wrong"</li>
<li> There are a variety of different sequencings of the declarations for the widgets, the signals, the methods, once again none are "right" or "wrong"</li>
<li> It is worth keeping in mind that PySide operates with strings when dealing with user input, what appears on the screen as a number is actually a text representation of a number</li></ul>
<h2><span class="mw-headline" id="Code_Based_Discussion_-_Declarative_Portion">Code Based Discussion - Declarative Portion</span></h2>
<p>The "example program" is actually a large Class definition, the definition of a PySide GUI class, and has over 150 lines of code (including comments). There is no functional purpose to the Class or it's behaviour, the sole purpose is to demonstrate possible GUI actions and present some code that hopefully can be used by other FreeCAD users.
</p><p>The Class definition and the small number of lines of code that invoke are described in the order the occur in the file. This order is based on the screen layout which is rather arbitrary and solely intended to demonstrate features. This is the modal GUI screen the PySide Class generates:
</p><p><a href="https://www.freecadweb.org/wiki/index.php?title=File:PySideScreenSnapshot3.jpg" class="image"><img alt="PySideScreenSnapshot3.jpg" src="PySideScreenSnapshot3.jpg" width="400" height="372" /></a>
</p><p><br />
Most of the remainder of this section will describe the contents of the Class definition which appears at the end of this section. First we will cover the declarative elements that define how things operate and how the GUI is assembled, then we will cover the operative sections (i.e. the code that will execute when user interactions occur). This window is based on the class QDialog and so is modal - which means no activities can be made outside of the window while it is open.
</p>
<h3><span class="mw-headline" id="Import_Statement">Import Statement</span></h3>
<p>The mandatory Import statement
</p>
<pre>from PySide import QtGui, QtCore </pre>
<p>This is best placed at the top of the Python file.
</p>
<h3><span class="mw-headline" id="Class_Definition">Class Definition</span></h3>
<pre>class ExampleModalGuiClass(QtGui.QDialog):
""""""
def __init__(self):
super(ExampleModalGuiClass, self).__init__()
self.initUI()
def initUI(self): </pre>
<p>This code is best copied out verbatim and altered. The gist of the code is that we are sub-classing the QDialog Class of PySide. In adapting this code you will want to change the class name "ExampleModalGuiClass" - make sure to change it in both locations (e.g. lines 1 &amp; 4).
</p>
<h3><span class="mw-headline" id="Window_Return_Status">Window Return Status</span></h3>
<pre>self.result = userCancelled </pre>
<p>This is not mandatory but rather a good programming practice, this sets a default return status for the window which will be there regardless of what the user does. Later in the code this may be changed by the Python code to indicate different options the user may have selected.
</p>
<h3><span class="mw-headline" id="Window_Creation">Window Creation</span></h3>
<pre># create our window
# define windowxLoc,yLoc,xDim,yDim
self.setGeometry(250, 250, 400, 350)
self.setWindowTitle("Our Example Program Window")
self.setWindowFlags(QtCore.Qt.WindowStaysOnTopHint) </pre>
<p>Remembering that screen dimensions are measured from the upper-left corner, on the 3rd line the values refer to:
</p>
<ul><li> the number of pixels the upper-left corner will be to the right of the lefthand screen edge (250)</li>
<li> the number of pixels the upper-left corner will be below the upper screen edge (250)</li>
<li> the width of the screen in pixels (400)</li>
<li> the height of the screen in pixels (350)</li></ul>
<p>The title of the window is set and the final line simply means that this window will never be obscured by another window - if this is not desired then simply place a Python comment character ('#') as the first character of the line.
</p>
<h3><span class="mw-headline" id="Label_Creation">Label Creation</span></h3>
<pre># create some Labels
self.label1 = QtGui.QLabel("                       ", self)
self.label1.setFont('Courier') # set to a non-proportional font
self.label1.move(20, 20)
self.label2 = QtGui.QLabel("sample string number two", self)
self.label2.move(20, 70)
self.label3 = QtGui.QLabel("                        ", self)
self.label3.setFont('Courier') # set to a non-proportional font
self.label3.move(20, 120)
self.label4 = QtGui.QLabel("can you see this?", self)
self.label4.move(20, 170) </pre>
<p>In PySide labels serve two purposes, static labels (as the name implies) as well as read-only (i.e. display-only) text fields. So unchanging instructions to the user such as "Don't push the red button" as well as dynamic calculation results such as "42" can be communicated to the user. The 2nd line declares a Label and sets it's initial value (which is blank in this case). The 3rd line specifies the font, any font (on the system) can be specified, if not specified the default font is used. In this case the font is specified as a non-proportional one. The label is moved to it's location in the window - it's coordinates specify it's position with respect to the window (not the screen).
</p>
<h3><span class="mw-headline" id="Checkbox_Creation">Checkbox Creation</span></h3>
<pre># checkboxes
self.checkbox1 = QtGui.QCheckBox("Left side", self)
self.checkbox1.clicked.connect(self.onCheckbox1)
#self.checkbox1.toggle() # will set an initial value if executed
self.checkbox1.move(210,10)
#
self.checkbox2 = QtGui.QCheckBox("Right side", self)
self.checkbox2.clicked.connect(self.onCheckbox2)
self.checkbox2.move(210,30) </pre>
<p>Checkboxes can be off and on in any combination (unlike radio buttons). Line 2 declares one and set's it initial Value. Line 3 specifies which method will be executed when the Checkbox is clicked (in this case the method 'onCheckBox1'). If the 4th line did not have the Python comment character ('#') as the first character, then it would be executed and it would mark the checkbox as checked. Finally the 5th line moves the Checkbox into position.
</p>
<h3><span class="mw-headline" id="Radio_Button_Creation">Radio Button Creation</span></h3>
<pre># radio buttons
self.radioButton1 = QtGui.QRadioButton("random string one",self)
self.radioButton1.clicked.connect(self.onRadioButton1)
self.radioButton1.move(210,60)
#
self.radioButton2 = QtGui.QRadioButton("owt gnirts modnar",self)
self.radioButton2.clicked.connect(self.onRadioButton2)
self.radioButton2.move(210,80) </pre>
<p>The creation of the Radio BUttons is very similar to the Checkboxes. The only difference really is the behaviour of the Radio Buttons in that only one of them can be 'on' at a time.
</p>
<h3><span class="mw-headline" id="Pop-Up_Menu_Creation">Pop-Up Menu Creation</span></h3>
<pre># set up lists for pop-ups
self.popupItems1 = ("pizza","apples","candy","cake","potatoes")
# set up pop-up menu
self.popup1 = QtGui.QComboBox(self)
self.popup1.addItems(self.popupItems1)
self.popup1.setCurrentIndex(self.popupItems1.index("candy"))
self.popup1.activated[str].connect(self.onPopup1)
self.popup1.move(210, 115) </pre>
<p>In line 2 a list is built up of what will be the user choices. An alternative is to build up a Dictionary but only use the Keys for the list of menu choices. Line 4 creates the pop-up menu (known as a ComboBox to PySide), the user options are added in line 5.
</p><p>As a side note, if the Dictionary was used then the lines would appear as:
</p>
<pre>self.popupItems1 = OrderedDict([("2","widget"),("pink","foobar"),("4","galopsis")])

self.popup1.addItems(self.popupItems1.keys()) </pre>
<p>Returning to the main code sample for this section, line 6 sets the default choice, this line may be omitted, also the value of the default choice could be loaded into the corresponding Label (once again if appropriate). And finally the move into position at line 8.
</p>
<h3><span class="mw-headline" id="Button_Creation_Part_1">Button Creation Part 1</span></h3>
<pre># toggle visibility button
pushButton1 = QtGui.QPushButton('Toggle visibility', self)
pushButton1.clicked.connect(self.onPushButton1)
pushButton1.setAutoDefault(False)
pushButton1.move(210, 165) </pre>
<p>The button is created in line 2 with it's name, the handler for it's signal when clicked is specified in line 3. Line 4 is there to prevent the button from becoming the 'default button' - the button that will be clicked if the user simply presses the <span style="background: #DDDDDD; border: 1px solid #888888; padding: 0px 5px 1px 5px;">Return</span> key. And a move to position finished up the code segment.
</p>
<h3><span class="mw-headline" id="Text_Input_Creation">Text Input Creation</span></h3>
<pre># text input field
self.textInput = QtGui.QLineEdit(self)
self.textInput.setText("cats &amp; dogs")
self.textInput.setFixedWidth(190)
self.textInput.move(20, 220) </pre>
<p>The QLineEdit widget is probably the most common for user textual input, in this example the code section after this one will set up a contextual menu to operate on it. This code section creates (line 2), sets an initial value (line 3), sets a width to the field (line 4) and moves the widget into place (line 5).
</p>
<h3><span class="mw-headline" id="Contextual_Menu_Creation">Contextual Menu Creation</span></h3>
<pre># set contextual menu options for text editing widget
# set text field to some dogerel
popMenuAction1 = QtGui.QAction(self)
popMenuAction1.setText("load some text")
popMenuAction1.triggered.connect(self.onPopMenuAction1)
# make text uppercase
popMenuAction2 = QtGui.QAction(self)
popMenuAction2.setText("uppercase")
popMenuAction2.triggered.connect(self.onPopMenuAction2)
# menu dividers
popMenuDivider = QtGui.QAction(self)
popMenuDivider.setText('---------')
popMenuDivider.triggered.connect(self.onPopMenuDivider)
# remove all text
popMenuAction3 = QtGui.QAction(self)
popMenuAction3.setText("clear")
popMenuAction3.triggered.connect(self.onPopMenuAction3)
# define menu and add options
self.textInput.setContextMenuPolicy(QtCore.Qt.ActionsContextMenu)
self.textInput.addAction(popMenuAction1)
self.textInput.addAction(popMenuAction2)
self.textInput.addAction(popMenuDivider)
self.textInput.addAction(popMenuAction3) </pre>
<p>This code has numerous repetitions as the same action is performed with different values - this is part of what makes GUI code so lengthy (no matter what the system). First a QAction is created - it is a pairing (or linkage) of the text that the user will see as their selectable option along with the method that will execute if they select that option. It is basically a pairing of a user choice with a piece of code. Line 3 creates it, line 4 defines the user option (as they will see it) and line 5 specifies which piece of Python code will execute.
</p><p>Skipping to line 19 (the line with "self.textInput.setContextMenuPolicy") a ActionsContextMenu is created which is holder for all the separate QAction linkages between user choice and code to execute. Each widget can only have a single Contextual Menu (i.e. the menu associated with the right-click) so line 19 defines that menu. The following 4 lines add the linkages created at the beginning of this code section. Order is significant here, the user will see the menu options in the order they are added. Notice that the 3rd menu option is really a bit of nothing, it's code is null but it serves to separate 2 groups of options on the Contextual Menu.
</p>
<h3><span class="mw-headline" id="Numeric_Input_Creation">Numeric Input Creation</span></h3>
<pre># numeric input field
self.numericInput = QtGui.QLineEdit(self)
self.numericInput.setInputMask("999")
self.numericInput.setText("000")
self.numericInput.setFixedWidth(50)
self.numericInput.move(250, 220) </pre>
<p>The creation of the field for numeric input really follows that for Text Input earlier. In fact the code is identical with exception of the 3rd and 4th lines. The 3rd line sets the Mask as defined by PySide, which in this case specifies up to 3 digits (which may include 0). A full list of the InputMask codes can be found at <a rel="nofollow" class="external text" href="http://doc.qt.io/qt-5/qlineedit.html#inputMask-prop">QLineEdit InputMask</a>
</p>
<h3><span class="mw-headline" id="Button_Creation_Part_2">Button Creation Part 2</span></h3>
<pre># cancel button
cancelButton = QtGui.QPushButton('Cancel', self)
cancelButton.clicked.connect(self.onCancel)
cancelButton.setAutoDefault(True)
cancelButton.move(150, 280)
# OK button
okButton = QtGui.QPushButton('OK', self)
okButton.clicked.connect(self.onOk)
okButton.move(260, 280) </pre>
<p>Both buttons are created with a name (which will appear as their label), associated with a method which will execute when they are clicked, and moved into position. The one exception is line 4 which specifies the 'Cancel' button as the default button - that means it will be "clicked" if the user preses the <span style="background: #DDDDDD; border: 1px solid #888888; padding: 0px 5px 1px 5px;">Return</span> key.
</p>
<h3><span class="mw-headline" id="Window_Display">Window Display</span></h3>
<pre># now make the window visible
self.show() </pre>
<p>There is only one line and it causes the GUI to be displayed after the setup.
</p>
<h2><span class="mw-headline" id="Code_Based_Discussion_-_Operative_Portion">Code Based Discussion - Operative Portion</span></h2>
<p>We now move onto the operative portion of the GUI definition which is the code that executes in response to user interactions with the GUI. The order of statement groups is not very relevant - with the caveat that something must be declared before it can be referenced. Some people put all the handlers of a certain type (e.g. handlers for buttons) in one group, others list the handlers alphabetically. For specific application there may be a problem related reason that all handlers relating to a specific aspect be gathered together
</p><p>There is a high degree of similarity between the handlers. Most do not receive a parameter, the fact they are executing is realy the only parameter (or signal) they get. Others like "onPopup1" and "mousePressEvent" accept a parameter.
</p><p>There must be a one to one correspondance between the handlers specified in the declarative section and the handler declared in this, the operative section. There may be extra handlers declared which are never invoked but there may not be any missing.
</p>
<h3><span class="mw-headline" id="Generic_Handler">Generic Handler</span></h3>
<p>In this code example, generic handlers handle the following events:
</p>
<ul><li> onCheckbox1</li>
<li> onCheckbox2</li>
<li> onRadioButton1</li>
<li> onRadioButton2</li>
<li> onPushButton1</li>
<li> onPopMenuAction1</li>
<li> onPopMenuAction2</li>
<li> onPopMenuDivider</li>
<li> onPopMenuAction3</li>
<li> onCancel</li>
<li> onOk</li></ul>
<p>The general form for the handlers is:
</p>
<pre>def handlerName(self):
lineOfCode1
lineOfCode2 </pre>
<p>The first line has the keyword "def" followed by the handler name. The handler name must match the name from the earlier declarative section exactly. The parameter "self" is part of the standard syntax as are the enclosing parenthesis and the final colon character. Once the first line is finished then there are no requirements of the following code, it is purely application specific.
</p>
<h3><span class="mw-headline" id="Pop-Up_Menu_Handler">Pop-Up Menu Handler</span></h3>
<pre>def onPopup1(self, selectedText): </pre>
<p>The Pop-Up menu handler is the same as the generic handler with exception that a second parameter, the text selected by the user, is passed in. Remember that everything is text coming from the Pop-Up menu and even if the user has selected the number 3, it will be passed in as the string "3".
</p>
<h3><span class="mw-headline" id="Mouse_Event_Handler">Mouse Event Handler</span></h3>
<pre>def mousePressEvent(self, event):
# print mouse position, X &amp; Y
print "X = ", event.pos().x()
print "Y = ", event.pos().y()
#
if event.button() == QtCore.Qt.LeftButton:
print "left mouse button"
if self.label1.underMouse():
print "over the text '"+self.label1.text()+"'" </pre>
<p>The Mouse Event handler is the same as the generic handler with exception that a second parameter, the mouse event (e.g. left-click, right-click) from the user is passed  in. The name of the handler, "mousePressEvent", is reserved and if it is changed then the handler will no longer receive the event from the mouse presses.
</p><p>The X and Y coordinates of the mouse press are given by the reference "event.pos().x()" and "event.pos().y()". The constants "QtCore.Qt.LeftButton" and "QtCore.Qt.RightButton" are used to determine which mouse button was pressed.
</p><p>A reference to a widget can be made of the form "self.widgetName.underMouse()" which will return <span style="color: #009900; background-color: #cef1ce;"><b>TRUE</b></span> or <span style="color: #990000; background-color: #f1cece;"><b>FALSE</b></span> as to whether the mouse cursor is over the widget "widgetName". Although presented in the same code excerpt the "underMouse()" handler is not tied to the "mousePressEvent" handler and can be used at any time.
</p>
<h2><span class="mw-headline" id="Code_Based_Discussion_-_Main_Routine">Code Based Discussion - Main Routine</span></h2>
<p>Most of the volume of code is in the GUI Class definition, there is not much in the main procedure.
</p>
<pre># Constant definitions
global userCancelled, userOK
userCancelled= "Cancelled"
userOK= "OK" </pre>
<p>Lines 2,3 &amp; 4 deal with coordinating the status of the user interaction with the GUI - e.g. Cancelled, OK, or any other application defined status. The handler routines On Cancel and OnOk earlier also set these statuses.
</p>
<pre>form = ExampleGuiClass()
form.exec_()

if form.result==userCancelled:
pass # steps to handle user clicking Cancel
if form.result==userOK:
# steps to handle user clicking OK
localVariable1 = form.label1.text()
localVariable2 = form.label2.text()
localVariable3 = form.label3.text()
localVariable4 = form.label4.text() </pre>
<p>Lines 1 and 2 show the method for invoking the GUI. There may be multiple GUI definitions for a program and also the GUI need not be invoked as the first thing in the Python file, it may be invoked at any point. The Name of the GUI Class is specified in line 1 ("ExampleGuiClass" in this case) but the rest of the 2 lines are to be copied verbatim.
</p><p>Lines 4 and 6 use the result field to determine the appropriate action. The last 4 lines simply show the copying of the data in the GUI object to variables local to the executing main procedure.
</p>
<h2><span class="mw-headline" id="Complete_Modal_Code_Example">Complete Modal Code Example</span></h2>
<p>This is the complete code example (developed on FreeCAD v0.14):
</p>
<div class="mw-highlight mw-content-ltr" dir="ltr"><pre># import statements

from PySide import QtGui, QtCore

# UI Class definitions

class ExampleModalGuiClass(QtGui.QDialog):
""""""
def __init__(self):
super(ExampleModalGuiClass, self).__init__()
self.initUI()
def initUI(self):
self.result = userCancelled
# create our window
# define windowxLoc,yLoc,xDim,yDim
self.setGeometry(250, 250, 400, 350)
self.setWindowTitle("Our Example Modal Program Window")
self.setWindowFlags(QtCore.Qt.WindowStaysOnTopHint)
# create some Labels
self.label1 = QtGui.QLabel("                       ", self)
self.label1.setFont('Courier') # set to a non-proportional font
self.label1.move(20, 20)
self.label2 = QtGui.QLabel("sample string number two", self)
self.label2.move(20, 70)
self.label3 = QtGui.QLabel("                        ", self)
self.label3.setFont('Courier') # set to a non-proportional font
self.label3.move(20, 120)
self.label4 = QtGui.QLabel("can you see this?", self)
self.label4.move(20, 170)
# checkboxes
self.checkbox1 = QtGui.QCheckBox("Left side", self)
self.checkbox1.clicked.connect(self.onCheckbox1)
#self.checkbox1.toggle() # will set an initial value if executed
self.checkbox1.move(210,10)
#
self.checkbox2 = QtGui.QCheckBox("Right side", self)
self.checkbox2.clicked.connect(self.onCheckbox2)
self.checkbox2.move(210,30)
# radio buttons
self.radioButton1 = QtGui.QRadioButton("random string one",self)
self.radioButton1.clicked.connect(self.onRadioButton1)
self.radioButton1.move(210,60)
#
self.radioButton2 = QtGui.QRadioButton("owt gnirts modnar",self)
self.radioButton2.clicked.connect(self.onRadioButton2)
self.radioButton2.move(210,80)
# set up lists for pop-ups
self.popupItems1 = ("pizza","apples","candy","cake","potatoes")
# set up pop-up menu
self.popup1 = QtGui.QComboBox(self)
self.popup1.addItems(self.popupItems1)
self.popup1.setCurrentIndex(self.popupItems1.index("candy"))
self.popup1.activated[str].connect(self.onPopup1)
self.popup1.move(210, 115)
# toggle visibility button
pushButton1 = QtGui.QPushButton('Toggle visibility', self)
pushButton1.clicked.connect(self.onPushButton1)
pushButton1.setAutoDefault(False)
pushButton1.move(210, 165)
# text input field
self.textInput = QtGui.QLineEdit(self)
self.textInput.setText("cats &amp; dogs")
self.textInput.setFixedWidth(190)
self.textInput.move(20, 220)
# set contextual menu options for text editing widget
# set text field to some dogerel
popMenuAction1 = QtGui.QAction(self)
popMenuAction1.setText("load some text")
popMenuAction1.triggered.connect(self.onPopMenuAction1)
# make text uppercase
popMenuAction2 = QtGui.QAction(self)
popMenuAction2.setText("uppercase")
popMenuAction2.triggered.connect(self.onPopMenuAction2)
# menu dividers
popMenuDivider = QtGui.QAction(self)
popMenuDivider.setText('---------')
popMenuDivider.triggered.connect(self.onPopMenuDivider)
# remove all text
popMenuAction3 = QtGui.QAction(self)
popMenuAction3.setText("clear")
popMenuAction3.triggered.connect(self.onPopMenuAction3)
# define menu and add options
self.textInput.setContextMenuPolicy(QtCore.Qt.ActionsContextMenu)
self.textInput.addAction(popMenuAction1)
self.textInput.addAction(popMenuAction2)
self.textInput.addAction(popMenuDivider)
self.textInput.addAction(popMenuAction3)
# numeric input field
self.numericInput = QtGui.QLineEdit(self)
self.numericInput.setInputMask("999")
self.numericInput.setText("000")
self.numericInput.setFixedWidth(50)
self.numericInput.move(250, 220)
# cancel button
cancelButton = QtGui.QPushButton('Cancel', self)
cancelButton.clicked.connect(self.onCancel)
cancelButton.setAutoDefault(True)
cancelButton.move(150, 280)
# OK button
okButton = QtGui.QPushButton('OK', self)
okButton.clicked.connect(self.onOk)
okButton.move(260, 280)
# now make the window visible
self.show()
#
def onCheckbox1(self):
text = self.label1.text()
if text[0]==' ':
self.label1.setText('left'+text[4:])
else:
self.label1.setText('    '+text[4:])
def onCheckbox2(self):
text = self.label1.text()
if text[-1]==' ':
self.label1.setText(text[:-5]+'right')
else:
self.label1.setText(text[:-5]+'     ')
def onRadioButton1(self):
self.label2.setText(self.radioButton1.text())
def onRadioButton2(self):
self.label2.setText(self.radioButton2.text())
def onPopup1(self, selectedText):
if self.label3.text().isspace():
self.label3.setText(selectedText)
else:
self.label3.setText(self.label3.text()+","+selectedText)
def onPushButton1(self):
if self.label4.isVisible():
self.label4.hide()
else:
self.label4.show()
def onPopMenuAction1(self):
# load some text into field
self.textInput.setText("Lorem ipsum dolor sit amet")
def onPopMenuAction2(self):
# set text in field to uppercase
self.textInput.setText(self.textInput.text().upper())
def onPopMenuDivider(self):
# this option is the divider and is really there as a spacer on the menu list
# consequently it has no functional code to execute if user selects it
pass
def onPopMenuAction3(self):
# clear the text from the field
self.textInput.setText('')
def onCancel(self):
self.result= userCancelled
self.close()
def onOk(self):
self.result= userOK
self.close()
def mousePressEvent(self, event):
# print mouse position, X &amp; Y
print "X = ", event.pos().x()
print "Y = ", event.pos().y()
#
if event.button() == QtCore.Qt.LeftButton:
print "left mouse button"
if self.label1.underMouse():
print "over the text '"+self.label1.text()+"'"
if self.label2.underMouse():
print "over the text '"+self.label2.text()+"'"
if self.label3.underMouse():
print "over the text '"+self.label3.text()+"'"
if self.label4.underMouse():
print "over the text '"+self.label4.text()+"'"
if self.textInput.underMouse():
print "over the text '"+self.textInput.text()+"'"
if event.button() == QtCore.Qt.RightButton:
print "right mouse button"

# Class definitions

# Function definitions

# Constant definitions
userCancelled= "Cancelled"
userOK= "OK"

# code ***********************************************************************************

form = ExampleModalGuiClass()
form.exec_()

if form.result==userCancelled:
pass # steps to handle user clicking Cancel
if form.result==userOK:
# steps to handle user clicking OK
localVariable1 = form.label1.text()
localVariable2 = form.label2.text()
localVariable3 = form.label3.text()
localVariable4 = form.label4.text()
print localVariable1
print localVariable2
print localVariable3
print localVariable4
#
#OS: Mac OS X
#Word size: 64-bit
#Version: 0.14.3703 (Git)
#Branch: releases/FreeCAD-0-14
#Hash: c6edd47334a3e6f209e493773093db2b9b4f0e40
#Python version: 2.7.5
#Qt version: 4.8.6
#Coin version: 3.1.3
#SoQt version: 1.5.0
#OCC version: 6.7.0
#</pre></div>
<p>The best way to use this code is to copy it into an editor or FreeCAD macro file and play around with it.
</p>
<h2><span class="mw-headline" id="Code_Based_Discussion_-_Nonmodal_Code_Example">Code Based Discussion - Nonmodal Code Example</span></h2>
<p>All of the widget specific from the previous modal example transfer to use in a nonmodal window. The main difference is that the nonmodal window does not restrict the user from interacting with other windows. Basically, a nonmodal window is one that can be opened and left open for as long as needed without it placing any restrictions on other application windows. There are a small number of code differences between the two which will be highlighted, consequently this code example is quite brief. Anything that is the same as the previous modal example will be left out in the interests of keeping this overview brief. This is the nonmodal GUI screen the PySide Class generates:
</p><p><a href="https://www.freecadweb.org/wiki/index.php?title=File:PySideScreenSnapshot4.jpg" class="image"><img alt="PySideScreenSnapshot4.jpg" src="PySideScreenSnapshot4.jpg" width="400" height="172" /></a>
</p>
<h3><span class="mw-headline" id="Import_Statement_2">Import Statement</span></h3>
<p>The mandatory Import statement
</p>
<pre>from PySide import QtGui, QtCore </pre>
<p>This is best placed at the top of the Python file.
</p>
<h3><span class="mw-headline" id="Class_Definition_2">Class Definition</span></h3>
<pre>class ExampleNonmodalGuiClass(QtGui.QMainWindow):
""""""
def __init__(self):
super(ExampleNonmodalGuiClass, self).__init__()
self.initUI()
def initUI(self): </pre>
<p>This code is best copied out verbatim and altered. The gist of the code is that we are sub-classing the QMainWindow Class of PySide. In adapting this code you will want to change the class name "ExampleNonmodalGuiClass" - make sure to change it in both locations (e.g. lines 1 &amp; 4).
</p>
<h3><span class="mw-headline" id="Window_Creation_2">Window Creation</span></h3>
<pre># create our window
# define windowxLoc,yLoc,xDim,yDim
self.setGeometry(250, 250, 400, 150)
self.setWindowTitle("Our Example Nonmodal Program Window")
self.setWindowFlags(QtCore.Qt.WindowStaysOnTopHint)
self.setMouseTracking(True) </pre>
<p>Obviously our window dimensions and title are different. The main point to note is the last line which lets PySide know that it is to send out mouse position events as they happen. Note that these events will not be sent out when the mouse is over a widget like a button as the widget will capture the events.
</p>
<h3><span class="mw-headline" id="Mouse_Move_Event_Handler">Mouse Move Event Handler</span></h3>
<pre>def mouseMoveEvent(self,event):
self.label6.setText("X: "+str(event.x()) + " Y: "+str(event.y())) </pre>
<p>This handler receives the event of a Mouse Move and displays the formatted form of it. Test what happens when it is over widgets or outside of the window.
</p>
<h3><span class="mw-headline" id="Invoking_the_Window">Invoking the Window</span></h3>
<pre>form = ExampleNonmodalGuiClass() </pre>
<p>Invoking the window is another area of difference from the previous example. This time only 1 line is needed for invoking the GUI.
</p>
<h2><span class="mw-headline" id="Complete_Nonmodal_Code_Example">Complete Nonmodal Code Example</span></h2>
<div class="mw-highlight mw-content-ltr" dir="ltr"><pre># import statements

from PySide import QtGui, QtCore

# UI Class definitions

class ExampleNonmodalGuiClass(QtGui.QMainWindow):
""""""
def __init__(self):
super(ExampleNonmodalGuiClass, self).__init__()
self.initUI()
def initUI(self):
self.result = userCancelled
# create our window
# define windowxLoc,yLoc,xDim,yDim
self.setGeometry(250, 250, 400, 150)
self.setWindowTitle("Our Example Nonmodal Program Window")
self.setWindowFlags(QtCore.Qt.WindowStaysOnTopHint)
self.setMouseTracking(True)
# create Labels
self.label4 = QtGui.QLabel("can you see this?", self)
self.label4.move(20, 20)
self.label5 = QtGui.QLabel("Mouse position:", self)
self.label5.move(20, 70)
self.label6 = QtGui.QLabel("               ", self)
self.label6.move(135, 70)
# toggle visibility button
pushButton1 = QtGui.QPushButton('Toggle visibility', self)
pushButton1.clicked.connect(self.onPushButton1)
pushButton1.setMinimumWidth(150)
#pushButton1.setAutoDefault(False)
pushButton1.move(210, 20)
# cancel button
cancelButton = QtGui.QPushButton('Cancel', self)
cancelButton.clicked.connect(self.onCancel)
cancelButton.setAutoDefault(True)
cancelButton.move(150, 110)
# OK button
okButton = QtGui.QPushButton('OK', self)
okButton.clicked.connect(self.onOk)
okButton.move(260, 110)
# now make the window visible
self.show()
#
def onPushButton1(self):
if self.label4.isVisible():
self.label4.hide()
else:
self.label4.show()
def onCancel(self):
self.result= userCancelled
self.close()
def onOk(self):
self.result= userOK
self.close()
def mouseMoveEvent(self,event):
self.label6.setText("X: "+str(event.x()) + " Y: "+str(event.y()))
# Class definitions

# Function definitions

# Constant definitions
global userCancelled, userOK
userCancelled= "Cancelled"
userOK= "OK"

# code ***********************************************************************************

form = ExampleNonmodalGuiClass()
#
#OS: Mac OS X
#Word size: 64-bit
#Version: 0.14.3703 (Git)
#Branch: releases/FreeCAD-0-14
#Hash: c6edd47334a3e6f209e493773093db2b9b4f0e40
#Python version: 2.7.5
#Qt version: 4.8.6
#Coin version: 3.1.3
#SoQt version: 1.5.0
#OCC version: 6.7.0
#</pre></div>
<h2><span class="mw-headline" id="Misc_Additional_Topics">Misc Additional Topics</span></h2>
<p>There are 3 concepts to the screen real estate in a GUI environment:
</p>
<ul><li> physical space on the screen</li>
<li> frame</li>
<li> geometry</li></ul>
<p>Within the software all are measured in pixels. PySide has function to measure in real world units but these are undependable as the manufacturers have no standard for pixel size or aspect ratio.
</p><p>The Frame is the size of a window including it's side bars, top bar (possibly with a menu in it) and bottom bar. The Geometry is the space lying within the Frame and so is always less than or equal to the Frame. In turn the Frame is always less than or equal to the available screen size.
</p>
<h3><span class="mw-headline" id="Available_Screen_Size">Available Screen Size</span></h3>
<pre># get screen dimensions (Available Screen Size)
screenWidth= QtGui.QDesktopWidget().screenGeometry().width()
screenHeight= QtGui.QDesktopWidget().screenGeometry().height()
# get dimensions for available space on screen
availableWidth= QtGui.QDesktopWidget().availableGeometry().width()
availableHeight= QtGui.QDesktopWidget().availableGeometry().height() </pre>
<p>Generally the "availableHeight" should be less than the "screenHeight" by the height of the menu bar. These 4 values are based on the hardware environment and will change from computer to computer. They are not dependent on any application window size.
</p>
<h3><span class="mw-headline" id="Frame_Size_and_Geometry">Frame Size and Geometry</span></h3>
<pre># set up a variable to hold the Main Window to save some typing...
mainWin = FreeCAD.Gui.getMainWindow()

mainWin.showFullScreen() # no menu bars, every last pixel is given over to FreeCAD
mainWin.geometry()
mainWin.frameSize()
mainWin.frameGeometry()

mainWin.showMaximized() # show maximised within the screen, window edges and the menu bar will be displayed
mainWin.geometry()
mainWin.frameSize()
mainWin.frameGeometry()

mainWin.showNormal() # show at the last non-maximised or non-minimised size (and location)
mainWin.geometry()
mainWin.frameSize()
mainWin.frameGeometry()

mainWin.setGeometry(50, 50, 800, 800) # specifically set FreeCAD main window's size and location, this will become the new setting for 'showNormal()'

mainWin.showMinimized() # FreeCAD will disappear from view after this command...
mainWin.geometry()
mainWin.frameSize()
mainWin.frameGeometry() </pre>
<p>These same commands can be executed on a user generated window, the syntax does not change.
</p>
<div style="clear:both"></div>
</div>



</div>

</div><div class="printfooter">
Online version: "<a dir="ltr" href="https://www.freecadweb.org/wiki/index.php?title=PySide_Medium_Examples/fr&amp;oldid=173821">http://www.freecadweb.org/wiki/index.php?title=PySide_Medium_Examples/fr&amp;oldid=173821</a>"</div>
<div id="catlinks" class="catlinks" data-mw="interface"></div><div class="visualClear"></div>
</div>
</div>
<div id="mw-navigation">
<h2>Navigation menu</h2>

</body></html>